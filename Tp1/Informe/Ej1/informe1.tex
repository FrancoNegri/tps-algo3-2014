\subsection{Introducci\'on} 

Cada participante de una competencia debe cruzar un puente dando saltos de tabl\'on en tabl\'on, con la limitación de que pueden saltar como m\'aximo una cantidad fija de tablones por vez. Sin embargo algunos de estos tablones est\'an rotos. El objetivo del ejercicio es dar un algoritmo que nos devuelva un recorrido por los tablones del puente el cual sea mínimo en la cantidad de saltos requeridos para poder cruzarlo con una complejidad temporal de \Ode{n} donde n es la cantidad de tablones del puente.

\subsection{Ejemplos y Soluciones}

Sea un puente de 14 tablones representado por el siguiente vector de 0 y 1, \verb+[0,0,0,1,1,0,0,1,0,1,0,0,1,0]+ llamado \verb+vector_puente+, donde 1 representa que el tabl\'on esta roto y 0 sano, y la primer posición del mismo el inicio del puente y la última el fin del mismo. Adicionalmente sabemos que la cantidad máxima de tablones que el participante puede saltar son 3 tablones.

Nuestro algoritmo va a encontrar la solución de la siguiente forma:
En cada paso el algoritmo goloso busca quedarse con la solucion optima, esta es el salto maximo que el participante puede saltar, con lo cual en cada paso de nuestro algoritmo lo que realiza es intetar este salto si es factible, en caso que el tablon esta sano saltamos a ese tablon y continuamos de manera iterativa, caso contrario comenzamos a revisar desde el salto maximo acercandonos tablon por tablon hasta la posicion actual hasta encontrar un tablon sano. Esto podria no ocurrir y en ese caso quiere decir que hay una cantidad de tablones rotos mayor al salto maximod el participante y en esta situacion no tenemos solucion.

\subsection{Desarrollo}

Para la soluci\'on de este problema recurrimos a la tecnica de algoritmos voraces, donde en cada paso en la construccion a la solucion obtenemos el mejor salto. 
Por el enunciado sabemos que tenemos n tablones, el participante puede saltar C tablones de una sola vez y cuales son las posiciones de los tablones rotos.Nos armamos un arreglo donde cada posici\'on representa un tabl\'on, en el cual guardamos 0 y 1 para indicar su estado (sano o roto respectivamente) llenando el mismo seg\'un la entrada, llamemoslo puente.
Nuestro algoritmo ira recorriendo el puente tratando de hacer el mayor salto cuando este es posible, dependiendo si el tablon al que iria a parar el participante esta sano, en caso contrario comenzamos a iterar los tablones desde este salto maximo hacia donde se encuentra parado el participante uno por uno hasta encontrar un tablon sano.\\
Para cada al cual se salta se guarda su posicion en una lista siempre insertando atras de la misma, una vez que cruzo participante cruzo todo el puente se devuelve esta lista como la sucesion de saltos realizada por el participante, en caso de no ser factible ya que en una seccion del puente la cantidad de tablones rotos consecutivos es mayor a el salto maximo se devuelve no, ya que no tiene solucion.


\subsection{Complejidad}
El siguiente es un pseudo-c\'odigo de nuestro algoritmo.\\


 \begin{algorithm}
  \begin{algorithmic}[1]\parskip=1mm
 \caption{ \\Saltos( salto\_Maximo : natural, puente : arreglo(1's y 0's), distancias: arreglo(naturales) , cantidadTablones : natural)}
 		\STATE{Si saltoMax $>$ cantidadTablones} \;\;
 		\STATE{\quad devolver 1} \;\;
 		\STATE{SI NO}\\
 		\STATE{nueva listaDeSaltos}\\
 		\STATE{\quad mientras posActual $<$ cantidadTablones } \;\; O(n)
 			\STATE{\quad\quad posibleSalto $=$ posActual + salto\_Maximo }\\
 			\STATE{\quad\quad mientras puente$($ posibleSalto $ ) $ $!=$ 1 $&$ posibleSalto $>$ 0}\\
 			\STATE{\quad\quad\quad  posibleSalto - 1 }\\
 			\STATE{\quad\quad SI posibleSalto $=$ posActual}\\
 			\STATE{\quad\quad\quad no hay solucion }\\
			\STATE{\quad\quad SI NO hay solucion }\\
 			\STATE{\quad\quad\quad AgregarAtras(posibleSalto,listaDeSaltos)}\\
 			\STATE{\quad\quad\quad posActual \leftarrow posibleSalto}\\
 			\STATE{\quad\quad Devolver listaDeSaltos}\\
  \end{algorithmic}
 Todas las asignaciones y comparaciones son en \Ode{1} como esta marcado en el pseudocodigo, ya que son números naturales y están acotados por la cantidad de tablones, en el caso del infinito este es representado por el máximo entero representable y este esta acotado.\\
 El ciclo de las lineas 5 - 15 se realiza n veces con lo cual la complejidad total del algoritmo es \Ode{n}, como saltoMax es una constante menor a n la complejidad total del algoritmo es \Ode{n}.

 \end{algorithm}	
\subsection{Demostraci\'on}
El algoritmo consta fundamentalmente en la eleccion del tablon mas lejano al que pueda saltar en cada paso y eso reside en ciclo interno de nuestro algoritmo:\\

\begin{algorithm}
	\begin{algorithmic}[1]\parskip=1mm
		\STATE{\quad\quad posibleSalto $=$ posActual + salto\_Maximo }\\
		\STATE{\quad\quad mientras puente$($ posibleSalto $ ) $ $!=$ 1 $&$ posibleSalto $>$ 0}\\
 		\STATE{\quad\quad\quad  posibleSalto - 1 }\\
 		\end{algorithmic}
 \end{algorithm}	
En este paso elegimos el proximo tablon al cual queremos saltar comenzando desde la posicion actual donde se encuentra el participante mas la longitud maxima del salto que puede realizar dicho participante, en caso que la guarda no se cumpla, que el tablon este sano, comenzamos a retroceder, una vez finalizado el ciclo revisamos si la posicion actual y la posicion del tablon al que queremos saltar es diferente, en este caso quiere decir que existe un tablon al cual queremos saltar.


		
\newpage			

\subsection{Experimentacion}
Para la experimentación del problema en cuestión se realizaron dos test, el primero teniendo en cuenta el peor caso, siendo este que todos los tablones del puente estén sanos y el salto máximo del participante sea uno, para esto se fijo el salto máximo y se crearon 1000 instancias de puentes sanos en tamaños que varian de 1 a 1000 luego se midieron los tiempos de ejecución dando como resultado el siguiente gráfico \\
\includegraphics[scale=0.7]{Ej1/sanos.jpg}\\
Como puede verse en el gráfico su complejidad esta en el orden lineal como puede compararse con la función, en el gráfico puede observar que algunos casos excede el orden, este ruido se debe a que puede haber ovaciones donde el sistema operativo este realizando otras tareas y afecte el orden de ejecución.

Para el segundo test se realizo un test aleatorio, para poder observar el comportamiento de todos los casos posibles, para esto se crearon 1000 instancias, en las cuales el tamaño del puente fue creciendo de 1 a 1000  y el salto máximo es un numero random entre 1 y la cantidad de tablones del puente para poder obtener también casos que no sean solución, dando comer resultado el siguiente gráfico.
\includegraphics[scale=0.7]{Ej1/Random.jpg}\\

Puede observarse que al igual en el test anterior el orden de complejidad esta en el orden lineal, de esta manera podemos concluir que nuestro algoritmo cumple con los ordenes de complejidad impuestos por el enunciado.

