\subsection{Introduccion} 
Se esta diseñando un software de arquitectura, para el cual es necesario que dado un conjunto de edificios representados como rectangulos apoyados sobre una base en comun, se devuelva el perfil definido en el horizonte.\\
Estos edificios vienen representados por tuplas de tres elementos que representan donde comienza el edificio, su altura y donde termina, de las cuales tenemos que ir tomando en cada momento donde comienza un edificio la altura maxima alcanzada en ese punto.

 \subsection{Ejemplos y Soluciones}
 Consideremos el siguiente ejemplo del problema:\\
 $ [<3,2,5>;<1,4,2>;<4,1,6>;<6,8,10>]$ \\
  Cada una de estas tuplas de tres elementos se indica donde comienza el edificio en la primera coordenada, su altura en la segunda y donde termina en la tercera coordenada.\\
  
  Lo primero que hacemos es ordenar estas tuplas en orden creciente por lo que representa donde comienza el edificio (llamemosla pared izquierda), quedandonos de la siguiente manera:\\ 
$[<1,4,2>;<3,2,5>;<4,1,6>;<6,8,10>$] \\

Por otro lado ordenamos los edificios por la coordenada donde terminan (llamemosla pared derecha).\\
$[<1,4,2>;<3,2,5>;<4,1,6>;<6,8,10>$] \\

\subsection{Desarrollo}
Como mencionamos anteriormente, tenemos como datos de entrada la posición donde comienza y termina cada edificio y además su altura, con lo cual representaremos a los edificios con tuplas de 3 elementos (posición de inicio o pared izquierda, altura, y posición donde termina o pared derecha). Primero organizaremos a los edificios en dos arreglos, donde cada arreglo contendrá el total de edificios, uno con un orden ascendente según pared izquierda y el otro también con un orden ascendente pero según pared derecha. Además tendremos un conjunto en el que iremos agregando los edificios que "comiencen" y quitando los edificios que "terminen", es decir, aquí estarán los edificios "activos" (que "empezaron" y no "terminaron") en cada momento.
La idea del algoritmo es ir recorriendo las posiciones (del eje x) en las que haya una o más paredes. En cada punto lo que haremos es agregar a mi conjunto de activos los edificios que en ese punto tengan su pared izquierda, o sea que estén "comenzando", y quitar a los edificios que allí tengan su pared derecha, o sea que estén "terminando". Una vez completada esta labor, buscaremos el edificio activo que tenga la altura máxima y nos lo guardaremos, llamémoslo Max. Se puede ver claramente que el borde superior de la silueta en un punto dado va a estar determinado por el edificio más alto que haya en ese punto, es decir, el edificio activo más alto. Como en cada paso podemos conseguir el edificio activo más alto, proseguiremos así hasta el último punto y habremos armádonos la silueta.

\subsection{Demostracion}
Demostraremos por inducción que en cada paso de este algoritmo obtenemos la altura del edificio más alto en ese punto.

P(i) = "Nuestro edificio Max es el edificio más alto en el punto i"

Caso base, P(1):
En este caso nos encontramos con nuestro primer conjunto de paredes, que puede tener una o más paredes. Este sólo puede tener paredes izquierda ya que es donde "comienzan" nuestros primeros edificios y ningún edificio ha empezado antes como para que aparezca una pared derecha indicando su "finalización". Por lo tanto tenemos un conjunto de edificios que "comienzan" en este punto y nos basta recorrer ese conjunto para encontrar el edificio de mayor altura, al cual llamaremos Max. Entonces, sin duda, Max es el edificio más alto en este punto.

Paso inductivo, P(n) $\rightarrow$ P(n+1):
Nuestra hipótesis inductiva nos dice que el edificio más alto en el punto n es Max. Ahora veamos qué ocurre en n+1. En este punto podemos encontrar un conjunto que contiene tanto paredes izquierda como derecha, con lo cual separaremos a este conjunto de paredes en dos subconjuntos. Por un lado el conjunto de paredes izquierda, y por otro el de paredes derecha. Recorreremos primero el conjunto de paredes izquierda agregando cada edificio de este conjunto al conjunto de edificios activos. Cada vez que alguno supere a nuestro Max actual, ese será el nuevo Max. Si después terminar el recorrido nuestro Max anterior cambió, entonces ese nuevo Max será el edificio más alto en este punto (y no es posible que este nuevo Max tenga su pared derecha en este punto ya que eso implicaría que ese edificio está "empezando" y "terminando" en el mismo punto, lo cual no es válido). Y caso contrario seguiremos manteniendo nuestro Max de antes y deberemos fijarnos las paredes derecha para ver si este Max "termina".
Ahora recorreremos el conjunto de paredes derecha quitando cada edificio que aparezca en este conjunto de nuestro conjunto de activos y fijándonos si está "terminando" el edificio Max en cada paso. Entonces cada vez que aparezca una pared derecha del edificio Max actual, lo reemplazaré por el edificio activo más alto. Por lo tanto, después de terminar el recorrido, nuestro edificio Max es el más alto de los edificios en ese punto.

Teniendo las alturas máximas para cada punto, es trivial armarnos la silueta ya que con las alturas máximas ya tenemos su borde superior en cada punto.


\subsection{Complejidad}

definimos edificio = < izq :natural x alto : natural x der : natural >
definimos edificioenCero al que tiene todos sus elementos en cero.

LaSilueta( ciudad: arreglo(edificios) , cantidadEdificios : natural)
	
	arregloXIzq \leftarrow ordenarXIzquierda(ciudad)
	arregloXDer \leftarrow ordenarXDerecha(ciudad)
	EdificiosActivos \leftarrow Multiconjunto(edificio)
	
	posIzquierdo , posDerecho \leftarrow 0
	max \leftarrow edificioenCero 
	mientras posIzquierdo < cantidadEdificios && posDerecho < cantidadEdificios 
		SI arregloXIzq.indice(posIquierdo).izq \leq arregloXDer.indice(posDerecho).der
			auxiliar \leftarrow arregloXIzq.indice(posIzquierdo)
			mientras auxiliar.izq = arregloXIzq.indice(posIquierdo).izq && posIzquierdo != cantidadEdificios
				agregar(arregloXIzq.indice(posIquierdo), EdificiosActivos )
				SI arregloXIzq.indice(posIquierdo).alto > max.alto
					max \leftarrow arregloXIzq.indice(posIquierdo)
		SI NO 
			auxiliar \leftarrow arregloXDer.indice(posDerecha)
			mientras auxiliar.der = arregloXDer.indice(posDerecha).der && posDerecha != cantidadEdificios
					SI  arregloXDer.indice(posDerecha).id = max.id
							dameMaximoSiguiente( arregloXDer.indice(posDerecha), EdificiosActivos)
				
					sacar( arregloXDer.indice(posDerecha), EdificiosActivos)
			
Los algoritmos ordenarXizquierda y ordenarXDerecha es el conocido algoritmo mergeSort sacado del libro de brassard, la complejidad es O(n*Log(n))
El multiconjunto EdificiosActivos esta representado con la estructura Multiset de c++, la relacion de orden sobre los elementos que se definio es por la altura y en el caso que la altura sea igual por derecha.
Las operacions para agregar, sacar elementos la complejidad es O(Log(n)) y para obtener el maximo lo que se realiza es obtener la referencia al elemento que 
representa el maximo, esto lleva O(Log(n)) y luego se obtiene el posterior, en caso de no ser posible obtenemos el anterior, siendo n la cantidad de elementos en el multiconjunto, en el peor caso son todos los edificios.
El algoritmo recorre cada pared izquierda y derecha del edificio con lo cual el total de iteraciones es 2*N, siendo N la cantidad total de edificios, como la complejidad de agregar , sacar y obtener el maximo es O(log(N)) en el peor caso, el total es O(2*N*Log(N)) \in O(N*Log(N))
 



				

\subsection{Experimentacion}

  



