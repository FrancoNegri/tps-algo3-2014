\section{Idea}


Para la metaheurística de GRASP, tomaremos el algoritmo goloso previamente implementado y lo combinaremos con las diferentes búsquedas locales también previamente implementadas.

La idea es la siguiente, para cada paso del algoritmo, correremos una versión modificada del goloso de manera tal de permitir cierta aleatoriedad en los resultados. El algoritmo goloso será modificado de la siguiente manera:

\begin{algorithm}
  \begin{algorithmic}[1]\parskip=1mm
 \caption{ Goloso()}
 		\STATE{Numero los vértices de $1$ a $n$} 
		\STATE{Creo una cantidad $k$ de conjuntos donde iré guardando vértices}
 		\STATE{Para cada nodo $i$ de $1$ a $n$: }
		\STATE{\quad Para cada conjunto}
			\STATE{\quad\quad Sumo todos los pesos de las aristas de ($i$,$j$) con $j$ los vértices que están en el conjunto}
 		\STATE{\quad De los mejores $x$ resultados, tomo uno al azar y pongo a $i$ en ese conjunto}
		\STATE{Devuelvo la respuesta}
\end{algorithmic}
\end{algorithm} 

Notar que si $x=1$ entonces estaríamos obteniendo el mismo algoritmo goloso que en el apartado anterior. En cambio, si tomo $x = k$ (esto es, tomo los $k$ mejores resultados, o sea todos), estaría generando una solución completamente aleatoria. Cualquier solución en medio tomará una solución golosa, pero con cierto grado de aleatoriedad.

Luego, a la solución obtenida por el algoritmo goloso modificado, se le aplicarán una o varias de las búsquedas locales implementadas, en un intento de acercarnos aún más a la respuesta óptima.

Como criterio de corte se correrá el goloso aleatorizado y la busqueda local hasta que luego de que un número $z$, a determinar, de intentos no haya sido posible mejorar la solución. En este punto se entrega la mejor respuesta obtenida hasta el momento.

Teniendo a nuestra disposición tres búsquedas locales distintas, decidimos desarrollar tres GRASPs de tal manera que combinen de forma diferente estas búsquedas. El primero sólo utiliza la búsqueda local $1$, el segundo utiliza las tres búsquedas locales en orden descendente, es decir, primero la $3$, luego la $2$ y por último la $1$, y finalmente, el tercer y último GRASP utiliza dos búsquedas locales, en primer lugar la $3$ y luego la $1$. A continuación se formaliza de manera más precisa los algoritmos de cada uno:

\begin{algorithm}
  	\begin{algorithmic}[1]\parskip=1mm
		 \caption{ GRASP 1(SoluciónInicial) }
		 \STATE{while(true)}
		 	\STATE{\quad Corro el Algoritmo Goloso modificado}
		 	\STATE{\quad Utilizo búsqueda local 1 para mejorar la solución obtenida previamente}
		 	\STATE{\quad Si conseguí una mejor solución que antes, la guardo}
		 	\STATE{\quad Si tras $z$ iteraciones no se pudo conseguir una mejor solución}
		 	\STATE{\quad\quad Devuelvo la solución}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  	\begin{algorithmic}[1]\parskip=1mm
		 \caption{ GRASP 2(SoluciónInicial) }
		 \STATE{while(true)}
		 	\STATE{\quad Corro el Algoritmo Goloso modificado}
		 	\STATE{\quad Utilizo búsqueda local 3 para mejorar la solución obtenida previamente}
		 	\STATE{\quad Utilizo búsqueda local 2 para mejorar aún más la solución obtenida previamente}
		 	\STATE{\quad Utilizo búsqueda local 1 para nuevamente mejorar la solución obtenida previamente}
		 	\STATE{\quad Si conseguí una mejor solución que antes, la guardo}
		 	\STATE{\quad Si tras $z$ iteraciones no se pudo conseguir una mejor solución}
		 	\STATE{\quad\quad Devuelvo la solución}
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  	\begin{algorithmic}[1]\parskip=1mm
		 \caption{ GRASP 3(SoluciónInicial) }
		 \STATE{while(true)}
		 	\STATE{\quad Corro el Algoritmo Goloso modificado}
		 	\STATE{\quad Utilizo búsqueda local 3 para mejorar la solución obtenida previamente}
		 	\STATE{\quad Utilizo búsqueda local 1 para mejorar aún más la solución obtenida previamente}
		 	\STATE{\quad Si conseguí una mejor solución que antes, la guardo}
		 	\STATE{\quad Si tras $z$ iteraciones no se pudo conseguir una mejor solución}
		 	\STATE{\quad\quad Devuelvo la solución}
	\end{algorithmic}
\end{algorithm}

En estos tres casos $z$ será un numero entero entre $1$ e infinito.

En el siguiente apartado de experimentación se intentarán calibrar tanto el parámetro $x$ como el parámetro $z$ para así obtener los mejores resultados posibles con estas metaheurísticas, tratando siempre de equilibrar performance y exactitud de los resultados.

\section{Experimentación}

Para poder llegar a nuestro objetivo de encontrar los mejores parámetros $x$ y $z$ a utilizar en las metaheurísticas, procederemos a hacer pruebas dejando fijo uno de los dos valores y variando el otro.
En primer lugar tomaremos un valor fijo arbitrario para $z$ y variaremos $x$. Esta prueba consistirá en tomar un grafo y un $k$ fijo, y correr cada metaheurística con ese grafo como entrada y variando el parámetro $x$. Una vez hecho esto, analizaremos para cuál valor de $x$ se llegó a una mejor solución, es decir, el que más minimizó el peso total. Este parámetro $x$ no podrá ser mayor que $k$ ya que si tengo $k$ conjuntos carece de sentido elegir entre los mejores $k'$ conjuntos siendo $k'>k$. Debido a lo previamente mencionado decidimos que $x$ sea un porcentaje de $k$, que variaremos entre $0$ y $100$ saltando de a 10, es decir, $x$ tomará los valores $0$, $10$, $20$,...,$90$ y $100$ 

Realizamos un primer experimento que consistió en lo siguiente:
Como primer paso generamos un grafo completo de $500$ nodos para tomarlo como entrada de los GRASPs junto a un $k=100$ fijo. Luego para cada valor de $x$ corrimos los tres GRASPs. Para cada uno de los GRASPs se obtuvo un $x$ ganador, es decir, el $x$ que minimizó el peso en cada caso. Este proceso se realizó 100 veces, siempre generando un grafo completo con pesos distintos en las aristas y en cada caso consiguiendo un $x$ ganador. A continuación se presenta un gráfico, en cual se encuentran los tres GRASPs, que muestra para cada $x$ cuántas de las 100 veces "ganó". 

%ACÁ EL GRÁFICO DE LOS 3 GRASP PARA 500 NODOS.

Por lo que se ve en el gráfico, puede inferirse que para $x=10$ se logran los mejores resultados en los tres GRASPs, al menos para el caso de 500 nodos. Para no quedarnos solamente con esta prueba, realizamos este mismo experimento nuevamente pero esta vez con $1000$ nodos. A continuación el gráfico correspondiente.

%ACÁ EL GRÁFICO DE LOS 3 GRASP PARA 1000 NODOS

Los resultados son claros, nuevamente $x=10$ es el ganador. Con esto podemos concluir con cierto grado de seguridad que el mejor valor para $x$ es $10$.

%------------------REVISAR ESTO---------------------
Respecto al tiempo que tardan los algoritmos, no se aprecian diferencias significativas, se podría decir que son despreciables.
%En realidad me parece que con un menor numero de cuantosMejores debería tardar menos... pero hay que fijarse lo que dieron las pruebas.

Observando las soluciones que se obtienen eligiendo el mejor valor para $x$, podemos decir que hay mejoras de aproximadamente un $1\%$.
%------------------REVISAR ESTO---------------------

Una vez obtenido el mejor valor para $x$, pasamos a buscar el mejor valor para $z$, con lo cual dejaremos fijo $x=10$ y variaremos el $z$.

Realizamos el segundo experimento, el cual consistió en hacer exactamente lo mismo que en el primer experimento pero esta vez variando $z$. A continuación se muestran los gráficos asociados.

%ACÁ EL GRÁFICO DE 500 NODOS
%Y ACÁ EL GRÁFICO DE 1000 NODOS

Como se puede ver en los gráficos, el resultado final no mejora por el hecho de iterar más veces una vez que no se llegó a una solución mejor, con lo cual se deduce que un bajo valor de $z$ será lo mejor ya que se estarían haciendo menos iteraciones y por lo tanto se reduciría el tiempo del algoritmo.

Finalmente con estos valores para $x$ y $z$, realizamos un último experimento para comparar las soluciones y los tiempos de cada GRASP.

Este último experimento consistió en:
%Bueno acá rellenar con lo que se hizo para comparar los GRASPs.

A continuación el gráfico que representa esta última comparación.
%Y poner el gráfico o los gráficos correspondientes acá (SOLUCIONES Y QUIZÁS TIEMPO)

Como se puede apreciar en el gráfico, el GRASP $...RELLENE AQUÍ...$ es el que llega a una mejor solución. Respecto a los tiempos se puede ver que ... %Bueno acá hay que poner algo coherente con lo que dieron los tiempos.

Para concluir, con todo lo visto hasta aquí, podemos afirmar con bastante certeza que el GRASP $...RELLENE AQUÍ...$ con los parámetros $x=10$ y $z=RELLENE AQUÍ$ es la metaheurística que mejor funciona, la más efectiva, es decir, la que mejor soluciones consigue en la relación al tiempo que tarda.